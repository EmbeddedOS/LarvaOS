Wiki: http://www.osdev.org/

1. Introduction:
    1.1. Basic Introduction:
        1.1.1. What is an Operating System?
            + An OS is a software controlling the operation of a computer system and its resources. \
                Among other things, there is one very important criteria common to all operating systems:
                + " Capable of loading and executing user programs providing standardized (hardware-independent) input / output interface for them."
            
            + Major functions of OS may include:
                + Managing memory and other system resources.
                + Imposing security and access policies.
                + Scheduling and multiplexing processes and threads.
                + Launching and closing user programs dynamically.
                + Providing a basic user interface and application programmer interface.
            
            + An OS is NOT:
                + the computer hardware.
                + A specific application such as a word processor, web browser or game.
                + A suite of utilities (like the GNU tools, which are used in many Unix-derived systems).
                + A development environment (though some OSes, such as UCSD Pascal or Smalltalk-80, incorporate an interpreter and IDE.).
                + A Graphical User Interface (though many modern Operating Systems incorporate a GUI as part of the OS.)

        1.1.2. What is a kernel?
            + The kernel of an OS is something you will never see. \
                It basically enables any other programs to execute. \
                it handles events generated by hardware (called interrupts) and software (called system calls), \
                and manages access to resources.

            + The hardware event handlers (interrupt handlers) will for instance get the number of the key you just pressed, \
                And convert it to the corresponding character stored in a buffer so some program can retrieve it. 

            + The system calls are initiated by user-level programs, \
                for opening files, starting other programs, etc. \
                Each system call handler will have to check whether the arguments passed are valid, \
                then perform the internal operation to complete the request.

            + Most user programs do not directly issue system calls (except for asm programs.), \
                But instead use STANDARD LIBRARY, \
                which does the ugly job of formatting arguments as required by the kernel and generating the system call. \
                (For example, the C function fopen() eventually calls a kernel function that actually opens the file.)

            + The kernel usually defines a few abstractions like files, processes, sockets, directories, etc. \
        
        1.1.3. What is shell?
            + A shell is special program that is usually integrated in an OS distribution, \
                and which offers humans an interface with the computer. \
                The way it appears to users may vary from system to system (command line, file explored, etc.), \
                But the concept is always the same:
                + Allow the user to select a program to be started, and optionally give it session-specific arguments.
                + Allow trivial operation on the local storage like listing the content of directories, \
                    moving and copying files across the system.

            + In order to complete those actions, the shell may have to issue numerous system calls, \
                like "open file 'x', open file 'y', and create it if it doesn't exist; read content from X, write into Y, clos both files, etc."

            + The shell may also be used by programs that want to start other programs but do not want to do this themselves.

            + Modern shell can also have various extra features, such as the following:
                + Auto-completion: By pressing the TAB key.
                + character insertion: the user can move around in what he or she entered by using the arrow keys. \
                    When typing new characters in the middle of a sentence, characters will get "inserted".
                + Shell History: By using the up and down arrow keys, the user can scroll through previous input.
                + Scrolling: When there are more lines than the console is high, \
                    Save the output in a buffer and allow the user to scroll up and down in the console.
                + Scripting: Some shells have custom scripting languages.

        1.1.4. What is a GUI about?
            + The Graphical User Interface is the most visible part of any operating system that has one. \
                Its role goes beyond a simple drawing library; it must also be able to:

                + Catch user input events (keyboard, mouse, etc.) and dispatch them to the proper object.
                + Update the internal information of what is to be displayed where on the screen, determining which parts of the screen need to be redrawn.
                + Update the visible screen contents, redrawing the necessary parts.
                + Do so in a way that feels natural, intuitive, and responsive to the user.

        1.1.5. Why develop an OS?
            + There are various reason why people choose to develop an operating system. \
                Each individual developer may have their own, \
                but some reasons are common among some (if not most) developers:
                + Having complete control over the machine. \
                    When developing an application or other user space program, \
                    the developer has to take the code written by others into consideration: \
                    The operating system, libraries, other programs, etc. 
                
                + Research. Quite a few OS projects are started as homework or research project.
                + To replace the currently available operating systems.

        1.1.6. Required Knowledge:
            + "If you think you can skip this, it's probably just for you."
            + Writing an OS is not beginner's task. \
                In fact, writing an OS is usually considered the most difficult programming task. \
                You will need above-average programming skills before even considering a project like this.
            
            + Some things you will need to know are:
                + Basic computer science: data structures, their construction and manipulation, searching and sorting algorithms, abstract programming concepts, etc. etc...
                + Language and Vocabulary: You need to be able to read and write (technical) English at a competent level.
                + Language and Vocabulary, pt. 2: Most operating systems featured on this site, as well as most of the code snippets and examples, are written in C (or C++).
                + Assembly.
                + Programming experience: you should also be familiar with version control, debugging, etc. 
                + UNIX experience.
                + Toolchain: You must know the behavioral details of your compiler, assembler, linker, and make utility. \
                    You should know what the emitted warnings and errors mean.
                + Emulators and Virtualizer:  Familiarity with tools such as Bochs, VirtualBox, QEMU, or Virtual PC is key to having a reasonable turn-around in development. 
                + Executable Formats: Kernel space programming has many additional requirements unknown to application development. \
                    Make yourself familiar with Executable File Types, their internal structure, and how a linker generates them.
                + The Platform: You should have studied the manuals for the processor you will be programming for. \
                    They contain the information you need to design your kernel in the first place.
                + The Concept: You should have an understanding of how existent operating systems function at the technical level (e.g. by having read some Books).
                
    1.2. Environment:
    1.3. Bare Bones, Baby Steps:
    1.3. Example OS organization:
    1.4. Booting and Setup:
        1.4.1. Boot Sequence:
        1.4.2. Diskless Booting:
        1.4.3. The Global Descriptor Table and a GDT Tutorial:
            + The Global Descriptor table (GDT) is a binary data structure specific to the IA-32 and x86-64 architectures. \
                It contains entries telling the CPU about memory segments. \
                A similar Interrupt Descriptor Table exists contains task and interrupt descriptor.
    
            1.4.3.1. Structure:
                + The GDT is loaded using the LGDT assembly instruction. \
                    It expects

2. Design Considerations:
    2.1. Kernel models:
    2.2. Task models:
    2.3. Memory and resource management:
    2.4. System calls:
    2.5. Scheduling:

3. Resources:

4. Tools:

5. Hardware:           
    5.1. CPU:
        5.1.1. General:
        5.1.2. X86:
            5.1.2.1. Modes:
                5.1.2.1.1. Real mode:
                5.1.2.1.2. Protected mode:
                    + Protected mode is the main operating mode of modern INTEL processors. \
                        The 32 bit protected mode allows working with several virtual address spaces, \
                        each of which has a maximum of 4Gb of addressable memory, \
                        and enables the system to enforce strict memory \
                        and hardware I/O protection as well as restricting the available instruction set via Rings (https://wiki.osdev.org/Security#Rings).

                    + A CPU that is initialized by the BIOS starts in Real Mode. \
                        Enabling Protected Mode unleashes the real power of your CPU. \
                        However, it will prevent you from using most of the BIOS interrupts, since these work in Real mode.

                    + Entering Protected Mode:
                        + Before switching to protected mode, you must:
                            + Disable interrupts, including NMI.
                            + Enable the A20 Line.
                            + Load the Global Descriptor Table with segment Descriptors suitable for code, data and stack.
                        + Whether the CPU is in Real Mode or in Protected Mode is defined by the lowest bit of the CR0 or MSW register.
                        + This example loads a Descriptor table into the processor's GDTR register, and then sets the lowest bit of CR0:
                            cli            ; disable interrupts
                            lgdt [gdtr]    ; load GDT register with start address of Global Descriptor Table
                            mov eax, cr0 
                            or al, 1       ; set PE (Protection Enable) bit in CR0 (Control Register 0)
                            mov cr0, eax
                            
                            ; Perform far jump to selector 08h (offset into GDT, pointing at a 32bit PM code segment descriptor) 
                            ; to load CS with proper PM32 descriptor)
                            jmp 08h:PModeMain
 
PModeMain:
; load DS, ES, FS, GS, SS, ESP





6. Reference information:
    6.1. Executable file type:
    6.2. File systems:
        6.2.1. FAT details:
            + The File Allocation Table (FAT) file system was introduced with DOS v1.0.
            + FAT is very simple file system -- nothing more than a singly-linked list of clusters in a gigantic table.
            + A FAT file system uses very little memory (unless the OS caches the whole allocation table in memory)\
                and is one of, if not the, most basic file system in use today.
            
            6.2.1.1. Overview:
            6.2.1.2. Implementation details:
                + The FAT file system views the storage media as a flat array of clusters. \
                    If the physical media does not address its data as a flat list of sectors (really old hard disks and floppy disks)\
                    then the cluster numbers will need to be translated before being sent to the disk. \
                    The storage media is organized into three basic areas.
                    + The boot record.
                    + The File Allocation Table (FAT).
                    + The directory and data area.

                + The BPB (BIOS Parameter Block).
                    + The boot record contains both code and data, mixed together. \
                        The data isn't code is known as the BPB.


            
11. Exceptions:
    + Exceptions, as described in this article, \
        are a type of interrupt generated by the CPU when an 'error' occurs.

    + Some Exceptions are not really errors in most case, such as Page faults.

    + Exceptions are classified as:
        + Faults: These can be corrected the program may continue as if nothing happened.
        + Traps: Traps are reported immediately after the executions of the trapping instruction.
        + Aborts: Some severe unrecoverable error.

    + Some exceptions will push a 32-bit "error code" on to the top of the stack, \
        Which provides additional information about the error. \
        This value must be pulled from the stack before \
        returning control back to the currently running program (i.e. before calling IRET).

    Name                        Vector nr.          Type            Mnemonic            Error code?
    Divide-by-zero Error        0 (0x0)             Fault           #DE                 No
    ...
    Stack-Segment fault         12 (0xC)            Fault           #SS                 Yes
    ...
    Page Fault	                14 (0xE)	        Fault	        #PF	                Yes