# Interrupts

The **Interrupts** are signals from a device, such as a keyboard or a hard drive, to the CPU, telling it to immediately **STOP** whatever it is currently doing and do something else.

For example, a keyboard controller can send an interrupt when a character key was pressed. Then the OS can display the character on screen immediately, even if the CPU was doing something completely unrelated before, and return to what it was afterwards.

When a specific interrupt arises, the CPU looks up an entry for that specific interrupt from a table provided by the OS. In x86 protected mode the table is called the [Interrupt Descriptor Table (IDT)](interrupt_descriptor_table.md) and can have up to **256** entries, but the name of this table and the maximum number of entries it can have can differ based on the CPU architecture.

After the CPU finds the entry for the interrupt, it jumps to the code the entry points to. This code that is run in response to the interrupt is known as [Interrupt Service Routine (ISR or an Interrupt Handler)](interrupt_service_routines.md).

## 1. Type of interrupts

There are generally **three** classes of interrupts on most platform:

* [Exceptions](exceptions.md): These are generated **internally by the CPU** and used to alert the running kernel of an event or situation which requires its attention. On x86 CPUs, these include exception conditions such as Double Fault, Page fault, General Protection, etc.
* **Interrupt Request (IRQ)** or **Hardware Interrupt**: This type of interrupt is generated **externally by the chipset**, and it is signaled by latching onto the #INTR pin or equivalent signal of the CPU in the question. These are **two types** of IRQs in common use today.
  * *IRQ Lines, or Pin-based IRQs*: These are typically statically routed on the chipset. Wires or lines run from the devices on the chipset to an IRQ controller which serializes the interrupt requests sent by devices, sending them to the CPU one by one to prevent races. In many cases, an IRQ Controller will send multiple IRQs to the CPU at once, based on the priority of the device.
  * *Message signaled interrupts*: These are signaled by writing a value to a memory location reserved for information about the interrupting device, the interrupt itself, and the vectoring information. The device is assigned a location to which it writes either by firmware ot the kernel software. Then, an IRQ is generated by the device using an arbitration protocol specific to the device' bus.
* **Software Interrupt**: This is an interrupt signaled by software running on a CPU to indicate that it needs the kernel's attention. Theses types of interrupts are generally used for [System Calls](system_calls.md). On x86 CPUs, the instruction which is used to initiate a software interrupt id the `INT` instruction. Since the x86 CPU can use any of the 256 available interrupts vectors for software interrupts, kernels generally choose one. For example, many contemporary Unixes use vector `0x80` on the x86 based platforms.

## 2. From the keyboard's perspective

Basically, when a key is pressed, the keyboard controller tells a device called [Programable Interrupt Controller](programmable_interrupt_controller.md), or **PIC**, to cause an interrupt. Because of the wiring of keyboard and PIC, IRQ#1 is the keyboard interrupts, so when a key is pressed, IRQ 1 sent to the PIC. The role of the PIC will be decide whether the CPU should be immediately notified of that IRQ or not and to translate the IRQ number into an *interrupt vector* (i.e. a number between 0 and 255) for the CPU's table.

The OS is supposed to handle the interrupt by talking to the keyboard, via `in` and `out` instruction, and returning to whatever code was executing when the interrupt cam in. Indeed, failure to read the key from the buffer will prevent any subsequent IRQs from the keyboard.

## 3. From the PIc's perspective

## 4. From the CPU's perspective

Every time the CPU is done with one machine instruction, it will check if the PIC's pin has notified an interrupt. if that's the case, it stores some state information on the stack (So that it can return to whatever it is doing currently, when the INT is done being serviced by the OS) and jumps to a location pointed to by the IDT. The OS takes over from there. The current program can, however, prevent the CPU from being disturbed by interrupts by means of the *interrupt flag* (IF in status register). As long as this flag is cleared, the CPU ignores the PIC's requests and continues running the current program. Assembly instructions `cli` and `sti` can control that flags.

## 5. From the OS's perspective

When an interrupt comes in, the [IDT](interrupt_descriptor_table.md) (which is setup by the OS in advance) is used to jump to code portion of the OS, which handles the interrupt (and therefore called the "interrupt handler" or "[Interrupt Service Routines](interrupt_service_routines.md)"). Usually the code interacts with the device, then returns to whatever it was doing previously with an `iret` instruction. before the `ret`, this code is executed, to tell the PIC that it's OK to send any new ot pending interrupts, because the current one is done. The PIC doesn't send any more interrupts until the cpu acknowledges the interrupt:

```asm
mov al, 20h
out 20h, al
```

In the case of the keyboard input, the interrupt handler asks the keyboard which key was pressed, does something with the information, then acknowledges and return:

```asm
push eax    ;; make sure you don't damage current state
in al,60h   ;; read information from the keyboard
 
mov al,20h
out 20h,al  ;; acknowledge the interrupt to the PIC
pop eax     ;; restore state
iret        ;; return to code executed before.
```

Whatever the CPU was previous doing is then resumed (unless another INT was received by the PIC while servicing this one, in which the PIC tells the CPU about it and a new interrupt handler is executed, once the CPU saves state information on the stack again).

## 6. So how do I program this stuff?

Step by step, now that you have grabbed the whole thing and know what's to be done:

* Make space for the interrupt descriptor table.
* Tell the CPU where that space is.
* Tell the PIC that you no longer want to use the BIOS default.
* Write a couple of ISR handlers for both IRQs and exceptions.
* Put the addresses of the ISR handlers in the appropriate descriptor.
* Enable all supported interrupts in the IRQ mask.

## 7. General IBM-PC Compatible Interrupt Information

Standard ISA IRQs

|IRQ|Description|
|---|-----------|
|0|Programmable Interrupt Timer Interrupt|
|1|Keyboard Interrupt|
|2|Cascade (used internally by the two PICs. never raised)|
|3|COM2 (if enabled)|
|4|COM1 (if enabled)|
|5|LPT2 (if enabled)|
|6|Floppy Disk|
|7|LPT1 / Unreliable "spurious" interrupt (usually)|
|8|CMOS real-time clock (if enabled)|
|9|Free for peripherals / legacy SCSI / NIC|
|10|Free for peripherals / SCSI / NIC|
|11|Free for peripherals / SCSI / NIC|
|12|PS2 Mouse|
|13|FPU / Coprocessor / Inter-processor|
|14|Primary ATA Hard Disk|
|15|Secondary ATA Hard Disk|
